# Spring-MVC

**Задача** : створити застосунок, для обробки даних, які надходять з пенетрометру — пристрою для контролю якості ущільнення ґрунту. Пристрій обладнаний GSM та GPS модулями. За допомогою GSM модуля, данні у вигляді файлу з певною кількістю замірів відправляються на застосунок використовуючи POST запит. Необхідно швидко оброблювати даний запит та коректно завантажувати всі данні в базу даних.

На наступній діаграмі, показаний Application Context, мого проекту:

![image](https://user-images.githubusercontent.com/89979281/158870595-2d6836fb-559d-4543-804e-e046ac0b2a4d.png)

Application Context Dependencies Diagram Мал. 6


Для виконання даного проекту вирішив використати **DAO паттерн**.

Об&#39;єкт доступу до даних (DAO) - це структурний паттерн, який дозволяє ізолювати застосунок / бізнес-логіку від частини де виконуються будь-які операції збереження (зазвичай це реляційна база даних, але може бути будь-який інший механізм збереження) за допомогою абстрактного API.

API приховує від реалізації всю складність виконання операцій CRUD в базовому механізмі збереження.Це дозволяє обом рівням працювати окремо, нічого не знаючи один про одного.[[3]](https://www.baeldung.com/java-dao-pattern)

Також використав **jdbcTemplate** для організації роботи з базою даних.

У багатьох фреймворках значна частина коду є шаблонним.

Наприклад, при виконанні запиту до бази даних необхідно виконати одну і ту ж серію кроків:

- Встановити з&#39;єднання
- Виконати запит
- Виконати очищення
- Закрити з&#39;єднання

Це ідеальний сценарій для патерну шаблонного методу. В мому випадку – jdbcTemplate.

Діаграма, що показує структуру бази даних в проекті:

![image](https://user-images.githubusercontent.com/89979281/158870719-f8ea8cff-03f7-436f-a628-36899c16df69.png)

Database Schema Мал. 7

Для зв&#39;язку представлення та моделі, використав технологію Thymeleaf.

Thymeleaf - це Java шаблонний движок для обробки та створення HTML, XML, JavaScript, CSS та тексту.

Ця бібліотека надзвичайно розширювана, а її природні можливості шаблонизації дозволяють створювати шаблони без бекенду. Це робить розробку дуже швидкою у порівнянні з іншими популярними шаблонизаторами, такими як JSP.[[4]](https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html)

Організація взаємодії Spring _бінів впроекті:_ 

![image](https://user-images.githubusercontent.com/89979281/158870776-e5afceeb-7461-4f50-9ad1-9c90289e02c5.png)

Bean Dependencies Diagram Мал. 8

Також основною частиною проекту є модуль Spring MVC.

Як випливає з назви, це модуль фреймворку Spring, який працює з патерном Model-View-Controller, або MVC.Він поєднує в собі всі переваги патерну MVC із зручністю Spring. Spring реалізує MVC із шаблоном фронт-контролера, використовуючи свій DispatcherServlet.

В двух словах, DispatcherServlet діє як головний контролер для маршрутизації запитів за призначенням.Модель - це не що інше, як дані нашої програми, а уявлення представлене будь-яким із різних шаблонизаторів.[[5]](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html)

**Алгоритм дій програми, коли надходить POST запит:**

1. Функція, що обробляє даний запит, приймає його тіло, у вигляді json списку, кожен об&#39;єкт, якого складається з полів: region (Регіон в якому знаходиться певна кількість полів, де була здійснена проба ґрунту), GPS (latitude та longitude) координати місця проби, та результ проби, тобто глибина на яку якісно оброблено землю (depth).
  1. Відбувається обробка даного запита в багатопоточному режимі, тому, якщо прийде наступний запит, сервер зможе його прийняти і почати обробку.
2. Далі з бази даних дістають всі поля, що належать до даного регіону, і починається процес пошуку відповідного поля.

    1. Якщо поле чи регіон не знайдено, є можливість реєстрації, як і області, де знаходяться поля (модель Area), так і поля з відповідними GPS координатами (модель Field) . Реалізовані CRUD операції для кожної з моделей (моделі Area, Field, Sample)

**Алгоритм, який я використав, щоб з&#39;ясувати, чи належить точка полю чи ні:**

Випускається промінь з цієї точки в довільному напрямку (при реалізації алгоритму зручно вибрати позитивний напрямок горизонтальної осі Ox), і рахується скільки разів промінь перетинає ребра многокутника. Для цього достатньо пройтися в циклі по ребрах многокутника і визначити, чи перетинає промінь кожне ребро. Якщо кількість перетинів непарна, то оголошується, що точка лежить всередині многокутника, якщо парна — то зовні. Метод засновано на тому простому спостереженні, що при русі по променю з кожним перетином кордону точка поперемінно виявляється то всередині, то зовні многокутника.

В алгоритмі виникає ускладнення в виродженому випадку, коли промінь перетинає вершину многокутника. Один зі способів його подолання полягає в тому, щоб вважати, що такі вершини многокутника лежать на нескінченно малу відстань вище (або нижче) променя, тоді будуть відсутні перетини в вершині. Таким чином, перетин променя з ребром зараховується, якщо кінці ребра лежать по різні боки від променя.

Алгоритм працює за час **O(N)** для **N-кутника.** [**[6]**](https://en.wikipedia.org/wiki/Point_in_polygon)

Діаграма класів проекту виглядає наступним чином:

![image](https://user-images.githubusercontent.com/89979281/158870832-87ce5b98-e871-41b5-b9a5-10f936ee08b1.png)

Java classes diagram Мал. 5

_Для виводу великої кількості даних організована пагінація, пакет класів в проекті Paging._

**Висновок**

Під час роботи над цим проектом, я набув нових знань та навичок у роботі з такими патернами, як DAO, REST, MVC, протоколом HTTP.

Ознайомився з базовими можливостями Spring Framework, та його модуля Spring MVC.

Дана робота дала мені нові ідеї у роботі як з Web застосунками, так і Java-додатками; дала орієнтир в якому я можу розвиватись та поглиблювати свої знання в розробці програмного забезпечення.
